// eslint-disable-next-line no-undef
const fs = require("fs");

const startStr = " = {";
const endStr = "};";
const commentHeader1 = "// The following strings have been translated by a machine translation service";
const commentHeader2 = "// Remove those strings that you have corrected manually";
// eslint-disable-next-line no-undef
module.exports = {
  isTranslationExists: function (fileName) {
    return fs.existsSync(this.getTranslationFileName(fileName));
  },
  getTranslationFileName: function(name) {
    if (name.indexOf(".ts") < 0) {
      name += ".ts";
    }
    return name;
  },
  readFile: function(fileName) {
    return fs.readFileSync(this.getTranslationFileName(fileName), "utf8");
  },
  readJson: function(name) {
    const text = this.readFile(name);
    const start = text.indexOf(startStr);
    const end = text.lastIndexOf(endStr);
    if (start < 0 || end < 0) return undefined;
    const content = text.substring(start + startStr.length, end);
    return eval("({" + content + "})");
  },
  getLocale: function(name) {
    const text = this.readFile(name);
    let subStr = "localeCode: \"";
    let index = text.indexOf(subStr);
    if (index < 0) return undefined;
    index += subStr.length;
    const endIndex = text.indexOf("\"", index);
    if (endIndex < 0) return undefined;
    return text.substring(index, endIndex);
  },
  convertLinesToText: function(lines) {
    for (let i = 0; i < lines.length; i ++) {
      let line = lines[i];
      if (i < lines.length - 1) {
        line = line + ",";
      }
      line = "\r\n  " + line;
      lines[i] = line;
    }
    lines.push("\r\n");
    return lines.join("");
  },
  replaceText: function(name, newText, missedKeys, translatedKeys) {
    const text = this.readFile(name);
    const start = text.indexOf(startStr);
    const end = text.lastIndexOf(endStr);
    let content = text.substring(0, start + startStr.length) +
      newText + text.substring(end);
    let missedKeysStr = "";
    let translatedKeysStr = "";
    if (name !== "english") {
      if (missedKeys > 0) {
        missedKeysStr = "// This dictionary contains " + missedKeys + " untranslated or inherited localization strings.\n// These strings are commented out. Uncomment and edit them if you want to add your translations.\n";
      }
      if (Array.isArray(translatedKeys)) {
        let keys = [""];
        if (text.indexOf(commentHeader1) < 0) {
          keys.push(commentHeader1);
          keys.push(commentHeader2);
        }
        for (let i = 0; i < translatedKeys.length; i ++) {
          const item = translatedKeys[i];
          keys.push("// " + item.key + ": " + JSON.stringify(item.english) + " => " + JSON.stringify(item.translation));
        }
        translatedKeysStr = keys.join("\n");
      }
      const importIndex = content.indexOf("import {");
      if (importIndex > 0) {
        content = content.substring(importIndex);
      }
    }
    fs.writeFileSync(this.getTranslationFileName(name), missedKeysStr + content + translatedKeysStr);
  },
  reportMessage: function(msg) {
    // eslint-disable-next-line
    console.log(msg);
  },
  getNewLineText: function(level) {
    return "\r\n".padEnd(2 + level * 2);
  },
  getKeyName: function(key) {
    if (key.indexOf("-") > -1 || key.indexOf("@") > -1 ||
      ["true", "false"].indexOf(key) > -1) return "\"" + key + "\"";
    return key;
  },
  updateTranslationKey: function(lines, missedKeys, englishJson, json, level, isEnglish, rootKey) {
    let propComment = "";
    const keys = Object.keys(englishJson);
    for (let i = 0; i < keys.length; i ++) {
      const key = keys[i];
      const hasComma = i < keys.length - 1;
      const commaText = hasComma ? "," : "";
      if (key.indexOf("license") > -1 && !isEnglish) continue;
      propComment = "";
      const keyName = this.getKeyName(key);
      if (this.isObject(englishJson, key)) {
        if (!!json && !json[key]) json[key] = {};
        if (!!this.keyComments[key]) {
          lines.push(this.getNewLineText(level) + "// " + this.keyComments[key]);
        }
        lines.push(this.getNewLineText(level) + keyName + ": {");
        this.updateTranslationKey(lines, missedKeys, englishJson[key], !!json ? json[key] : undefined, level + 1, isEnglish, key);
        lines.push(this.getNewLineText(level) + "}" + commaText);
      } else {
        let hasValue = !!json && json[key] !== undefined;
        let value = hasValue ? json[key] : englishJson[key];
        let line = keyName.toString() + ": " + JSON.stringify(value);
        if (isEnglish) {
          if (!hasValue) {
            line = keyName.toString() + ": " + JSON.stringify(this.getGeneratedEnglishName(keyName));
            if (!this.propertiesComments[key]) {
              this.propertiesComments[key] = " " + this.autoGeneratedStr;
            }
          } else {
            if (!this.propertiesComments[key] && this.autoGeneratedEnglishKeys[key] === rootKey) {
              this.propertiesComments[key] = " " + this.autoGeneratedStr;
            }
          }
        } else {
          if (!!json && !hasValue || !json && key === value) {
            line = "// " + line;
            const comment = !!this.propertiesComments[key] ? " //" + this.propertiesComments[key] : "";
            missedKeys.push({ propKey: key, key: rootKey + "." + key, english: englishJson[key],
              lineIndex: lines.length, level: level, hasComma: hasComma, comment: comment });
          }
        }
        lines.push(this.getNewLineText(level) + line + commaText);
        propComment = !!this.propertiesComments[key] ? " //" + this.propertiesComments[key] : "";
      }
      if (!!propComment) {
        lines[lines.length - 1] += propComment;
      }
    }
    return missedKeys;
  },
  isObject: function(englishJson, name) {
    const val = englishJson[name];
    return !(typeof val === "string" || val instanceof String);
  },
  getGeneratedEnglishName: function(name) {
    if (!name) return name;
    let res = name[0].toUpperCase();
    for (var i = 1; i < name.length; i ++) {
      if (name[i] === name[i].toUpperCase() && name[i - 1] !== name[i - 1].toUpperCase()) {
        res += " ";
        if (i < name.length - 1 && name[i + 1] !== name[i + 1].toUpperCase()) {
          res += name[i].toLowerCase();
        } else {
          res += name[i];
        }
      } else {
        res += name[i];
      }
    }
    return res;
  },
  updateAlternativeNamesInJSON: function(json) {
    for (let alternativeName in this.alternativeNames) {
      const newName = this.alternativeNames[alternativeName];
      const value = json.pe[alternativeName];
      if (!!value) {
        if (!json.pe[newName]) {
          json.pe[newName] = value;
        }
        delete json.pe[alternativeName];
      }
    }
  },
  readComments: function(name) {
    const text = this.readFile(name);
    const translations = [];
    const lines = text.split("\n");
    lines.forEach(line => {
      const trimmed = line.trim();
      if (trimmed.startsWith("//")) {
        const content = trimmed.slice(2).trim();
        const parts = content.split(":");
        if (parts.length >= 2) {
          const key = parts[0].trim();
          const rest = parts.slice(1).join(":").trim();
          const match = rest.match(/^"([^"]+)"\s*=>\s*"([^"]+)"$/);
          if (match) {
            const englishString = match[1];
            const translated = match[2];
            translations.push({ key, english, translation });
          }
        }
      }
    });
    return translations;
  },
  findFullPath: function(json, key) {
    const segments = key.split(".");
    if (segments.length < 2) return undefined; // As per the requirement, key contains at least the last node and the previous one

    function search(obj, currentPath) {
      if (typeof obj !== "object" || obj === null) return undefined;

      // Try matching the segments from the current object
      let temp = obj;
      let i = 0;
      for (; i < segments.length; i++) {
        const seg = segments[i];
        if (typeof temp !== "object" || !(seg in temp)) {
          break;
        }
        temp = temp[seg];
      }

      if (i === segments.length) {
        return [...currentPath, ...segments];
      }

      // Recurse into sub-objects
      for (const k in obj) {
        if (typeof obj[k] === "object" && obj[k] !== null) {
          const result = search(obj[k], [...currentPath, k]);
          if (result !== undefined) return result;
        }
      }

      return undefined;
    }

    return search(json, []);
  },
  getJsonValue: function(json, path) {
    for (let i = 0; i < path.length; i++) {
      const key = path[i];
      if (json && typeof json === "object" && key in json) {
        json = json[key];
      } else {
        return undefined;
      }
    }
    return json;
  },
  collectJsonComments: function(code) {
    const result = [];
    let i = 0;
    const len = code.length;

    function skipWhitespace() {
      while(i < len && /\s/.test(code[i])) i++;
    }

    function skipSpace() {
      while(i < len && (code[i] === " " || code[i] === "\t")) i++;
    }

    function skipComment() {
      if (code[i] === "/" && code[i + 1] === "/") {
        i += 2;
        skipSpace();
        let start = i;
        while(i < len && code[i] !== "\n" && code[i] !== "\r") i++;
        let comment = code.substring(start, i).trim();
        if (code[i] === "\r") i++;
        if (code[i] === "\n") i++;
        return comment;
      }
      return null;
    }

    function parseString() {
      let quote = code[i];
      i++;
      let start = i;
      let str = "";
      while(i < len) {
        if (code[i] === "\\") {
          str += code.substring(start, i);
          i++;
          if (i < len) {
            str += code[i];
            i++;
          }
          start = i;
        } else if (code[i] === quote) {
          str += code.substring(start, i);
          i++;
          return str;
        } else {
          i++;
        }
      }
      throw new Error("Unterminated string");
    }

    function parseNumber() {
      if (code[i] === "-" || /\d/.test(code[i])) {
        while(i < len && /[\d.eE+-]/.test(code[i])) i++;
      } else {
        throw new Error("Expected number");
      }
    }

    function parseValue() {
      skipWhitespace();
      if (code[i] === "{") {
        return "object";
      } else if (code[i] === '"' || code[i] === "'") {
        parseString();
        return "string";
      } else if (code[i] === "-" || /\d/.test(code[i])) {
        parseNumber();
        return "number";
      } else if (code.substr(i, 4) === "true") {
        i += 4;
        return "boolean";
      } else if (code.substr(i, 5) === "false") {
        i += 5;
        return "boolean";
      } else if (code.substr(i, 4) === "null") {
        i += 4;
        return "null";
      } else {
        throw new Error("Unexpected value");
      }
    }

    function parseObject(currentPath) {
      skipWhitespace();
      if (code[i] !== "{") throw new Error("Expected {");
      i++; // skip {
      while(true) {
        skipWhitespace();
        let leadingComments = [];
        let comment;
        while((comment = skipComment())) {
          if (comment) leadingComments.push(comment);
        }
        skipWhitespace();
        if (code[i] === "}") {
          i++;
          break;
        }
        // Parse key
        let key;
        if (code[i] === '"' || code[i] === "'") {
          key = parseString();
        } else {
          let start = i;
          while(i < len && /[a-zA-Z0-9_$]/.test(code[i])) i++;
          key = code.substring(start, i);
          if (!key) throw new Error("Expected key");
        }
        let fullPath = currentPath ? currentPath + "." + key : key;
        skipWhitespace();
        if (code[i] !== ":") throw new Error("Expected :");
        i++; // skip :
        const valueType = parseValue();
        if (valueType === "object") {
          parseObject(fullPath);
        }
        // Trailing comment (same line)
        skipSpace();
        let trailingComment = skipComment();
        // Add comments to result
        leadingComments.forEach(c => {
          result.push({ key: fullPath, comment: c, position: "top" });
        });
        if (trailingComment) {
          result.push({ key: fullPath, comment: trailingComment, position: "right" });
        }
        skipWhitespace();
        if (code[i] === ",") {
          i++;
        } else if (code[i] === "}") {
          i++;
          break;
        } else {
          throw new Error("Expected , or }");
        }
      }
    }

    // Find the start of the exported object
    while(i < len) {
      skipWhitespace();
      if (code.substr(i, 6) === "export") {
        i += 6;
        skipWhitespace();
        // Skip var/let/const
        if (code.substr(i, 5) === "const") {
          i += 5;
        } else if (code.substr(i, 3) === "let" || code.substr(i, 3) === "var") {
          i += 3;
        } else {
          continue;
        }
        skipWhitespace();
        // Skip variable name
        while(i < len && /[a-zA-Z0-9_$]/.test(code[i])) i++;
        skipWhitespace();
        if (code[i] === "=") {
          i++;
          skipWhitespace();
          if (code[i] === "{") {
            parseObject("");
            return result;
          }
        }
      } else {
        i++;
      }
    }
    throw new Error("No exported object found");
  },
  autoGeneratedStr: "Auto-generated string",
  autoGeneratedEnglishKeys: {},
  alternativeNames: {},
  keyComments: {
    survey: "survey templates",
    tabs: "Creator tabs",
    qt: "Question types",
    ed: "Strings in SurveyJS Creator",
    pe: "Property Editors",
    pv: "Property values",
    op: "Operators",
    ew: "Embed window",
    ts: "Preview (Survey)",
    p: "Properties"
  },
  propertiesComments: {
    addNewTypeQuestion: "{0} is localizable question type",
    itemExpressionText: "{0} - the expression",
    page_visibilityText: "{0} page name",
    panel_visibilityText: "{0} panel name",
    panel_enableText: "{0} panel name",
    question_visibilityText: "{0} question name",
    question_enableText: "{0} question name",
    question_requireText: "{0} question name",
    column_visibilityText: "{0} column name, {1} question name",
    column_enableText: "{0} column name, {1} question name",
    column_requireText: "{0} column name, {1} question name",
    trigger_setvalueEmptyText: "{0} question name",
    trigger_setvalueText: "{0} question name, {1} setValue",
    trigger_copyvalueText: "{0} and {1} question names",
    trigger_skipText: "{0} question name",
    trigger_runExpressionText1: "{0} the expression",
    trigger_runExpressionText2: "{0} question name",
    question_resetValueText: "{0} question name.",
    column_resetValueText: "{0} column name",
    column_setValueText: "{0} column name and {1} setValueExpression"
  }
};