/* eslint no-use-before-define: 0 */
/**
 * Finds missed (untranslated) strings in translation
 * Add missed strings as comments in translation
 * Example of running to update french.ts  and all translation files:
 * node translations_update french
 * node translations_update all
 */
// eslint-disable-next-line no-undef
const fs = require("fs");
// eslint-disable-next-line no-undef
const survey = require("survey-core");
// eslint-disable-next-line no-undef
const utils = require("./translation_utils");
const autoGeneratedStr = "Auto-generated string";
const autoGeneratedEnglishKeys = {};

const alternativeNames = {};
const keyComments = {
  survey: "survey templates",
  qt: "Question types",
  ed: "Strings in SurveyJS Creator",
  pe: "Property Editors",
  pv: "Property values",
  op: "Operators",
  ew: "Embed window",
  ts: "Preview (Survey)",
  p: "Properties"
};
const propertiesComments = {
  addNewTypeQuestion: "{0} is localizable question type",
  itemExpressionText: "{0} - the expression",
  page_visibilityText: "{0} page name",
  panel_visibilityText: "{0} panel name",
  panel_enableText: "{0} panel name",
  question_visibilityText: "{0} question name",
  question_enableText: "{0} question name",
  question_requireText: "{0} question name",
  column_visibilityText: "{0} column name, {1} question name",
  column_enableText: "{0} column name, {1} question name",
  column_requireText: "{0} column name, {1} question name",
  trigger_setvalueEmptyText: "{0} question name",
  trigger_setvalueText: "{0} question name, {1} setValue",
  trigger_copyvalueText: "{0} and {1} question names",
  trigger_skipText: "{0} question name",
  trigger_runExpressionText1: "{0} the expression",
  trigger_runExpressionText2: "{0} question name"
};
// eslint-disable-next-line no-undef
let arg = process.argv;
if(!Array.isArray(arg)) return;
if(arg.length < 3) {
  utils.reportMessage("You should pass file name as parameter or 'all'");
  return;
}
let parameter = arg[2].toLocaleLowerCase();
const englishJSON = utils.readJson("english");
addPropertiesIntoEnglishJSON(englishJSON);
updateAlternativeNamesInJSON(englishJSON);
if(parameter === "english") {
  updateEnglishTranslation();
  return;
}
if(parameter === "all") {
  fs.readdir(".", function (err, files) {
    if (err) {
      utils.reportMessage("Unable to scan directory: " + err);
      return;
    }
    files.forEach(function (file) {
      if(file.indexOf(".ts") > 0 && file !== "english.ts") {
        updateTranslation(file);
      }
    });
  });
} else {
  if(!utils.isTranslationExists(parameter)) {
    utils.reportMessage("There is no translation file: " + utils.getTranslationFileName(parameter));
    return;
  }
  updateTranslation(parameter);
}
function updateTranslation(name) {
  const json = utils.readJson(name);
  if(!json) return;
  updateAlternativeNamesInJSON(json);
  const lines = [];
  let missedKeys = updateTranslationKey(lines, englishJSON, json, 1);
  lines.push(getNewLineText(0));
  if(missedKeys > 0) {
    utils.replaceText(name, lines.join(""), missedKeys);
    utils.reportMessage("Updated file: " + utils.getTranslationFileName(name));
  } else {
    utils.reportMessage("All strings are translated in file: " + utils.getTranslationFileName(name));
  }
}
function updateEnglishTranslation() {
  const lines = [];
  const json = utils.readJson("english.ts");
  updateEnglishAutoGeneratedKey();
  updateTranslationKey(lines, englishJSON, json, 1, true);
  lines.push(getNewLineText(0));
  utils.replaceText("english", lines.join(""), 0);
  utils.reportMessage("Updated file: " + utils.getTranslationFileName("english"));
}
function getNewLineText(level) {
  return "\r\n".padEnd(2 + level * 2);
}
function getKeyName(key) {
  if(key.indexOf("-") > -1 || key.indexOf("@") > -1 ||
    ["true", "false"].indexOf(key) > -1) return "\"" + key + "\"";
  return key;
}
function updateEnglishAutoGeneratedKey() {
  const text = utils.readFile("english.ts");
  const lines = text.split("\n");
  const keyNames = [];
  for(let i = 0; i < lines.length; i ++) {
    const str = lines[i].trim();
    if(str.endsWith("{")) {
      const index = str.indexOf(":");
      const name = index > -1 ? str.substring(0, index).trim() : "";
      keyNames.push(name);
    }
    if(str.endsWith("},")) {
      keyNames.pop();
    }
    if(str.indexOf(autoGeneratedStr) > -1) {
      const keyName = keyNames.length > 0 ? keyNames[keyNames.length - 1] : "";
      const index = str.indexOf(":");
      if(index > -1 && !!keyName) {
        let keyStr = str.substring(0, index).trim().replace("\"", "");
        autoGeneratedEnglishKeys[keyStr] = keyName;
      }
    }
  }
}
function updateTranslationKey(lines, englishJson, json, level, isEnglish, rootKey) {
  let missedKeys = 0;
  let isStarted = true;
  let propComment = "";
  for(let key in englishJson) {
    if(key === "license" && !isEnglish) continue;
    if(!isStarted) {
      lines[lines.length - 1] += "," + propComment;
    }
    propComment = "";
    isStarted = false;
    const keyName = getKeyName(key);
    if(isObject(englishJson, key)) {
      if(!!json && !json[key]) json[key] = {};
      if(!!keyComments[key]) {
        lines.push(getNewLineText(level) + "// " + keyComments[key]);
      }
      lines.push(getNewLineText(level) + keyName + ": {");
      missedKeys += updateTranslationKey(lines, englishJson[key], !!json ? json[key] : undefined, level + 1, isEnglish, key);
      lines.push(getNewLineText(level) + "}");
    } else {
      let hasValue = !!json && json[key] !== undefined;
      let value = hasValue ? json[key] : englishJson[key];
      let line = keyName.toString() + ": " + JSON.stringify(value);
      if(isEnglish) {
        if(!hasValue) {
          line = keyName.toString() + ": " + JSON.stringify(getGeneratedEnglishName(keyName));
          if(!propertiesComments[key]) {
            propertiesComments[key] = " " + autoGeneratedStr;
          }
        } else {
          if(!propertiesComments[key] && autoGeneratedEnglishKeys[key] === rootKey) {
            propertiesComments[key] = " " + autoGeneratedStr;
          }
        }
      } else {
        if(!!json && !hasValue || !json && key === value) {
          line = "// " + line;
          missedKeys ++;
        }
      }
      lines.push(getNewLineText(level) + line);
      propComment = !!propertiesComments[key] ? " //" + propertiesComments[key] : "";
    }
  }
  if(!!propComment) {
    lines[lines.length - 1] += propComment;
  }
  return missedKeys;
}
function getGeneratedEnglishName(name) {
  if(!name) return name;
  let res = name[0].toUpperCase();
  for(var i = 1; i < name.length; i ++) {
    if(name[i] === name[i].toUpperCase() && name[i - 1] !== name[i - 1].toUpperCase()) {
      res += " ";
      if(i < name.length - 1 && name[i + 1] !== name[i + 1].toUpperCase()) {
        res += name[i].toLowerCase();
      } else {
        res += name[i];
      }
    } else {
      res += name[i];
    }
  }
  return res;
}
function isObject(englishJson, name) {
  const val = englishJson[name];
  return !(typeof val === "string" || val instanceof String);
}
function addPropertiesIntoEnglishJSON(json) {
  const classes = survey.Serializer.getAllClasses();
  const properties = [];
  const propertiesHash = {};
  classes.forEach(name => {
    const cl = survey.Serializer.findClass(name);
    cl.properties.forEach(prop => {
      properties.push(prop);
      propertiesHash[prop.name] = prop;
      if(!!prop.alternativeName) {
        alternativeNames[prop.alternativeName] = prop.name;
      }
    });
  });
  for(let propName in propertiesHash) {
    if(!json.pe[propName] && !json.p[propName]) {
      json.p[propName] = propName;
    }
    if(!!alternativeNames[propName]) {
      delete alternativeNames[propName];
    }
  }
}
function updateAlternativeNamesInJSON(json) {
  for(let alternativeName in alternativeNames) {
    const newName = alternativeNames[alternativeName];
    const value = json.pe[alternativeName];
    if(!!value) {
      if(!json.pe[newName]) {
        json.pe[newName] = value;
      }
      delete json.pe[alternativeName];
    }
  }
}